--- a/build/linux/unbundle/absl_algorithm.gn
+++ b/build/linux/unbundle/absl_algorithm.gn
@@ -20,3 +20,5 @@ source_set("algorithm_test") {
 }
 source_set("container_test") {
 }
+source_set("algorithm") {
+}
--- a/build/linux/unbundle/absl_base.gn
+++ b/build/linux/unbundle/absl_base.gn
@@ -103,3 +103,33 @@ source_set("nullability_test") {
 }
 source_set("prefetch_test") {
 }
+source_set("dynamic_annotations") {
+}
+source_set("fast_type_id") {
+}
+source_set("log_severity") {
+}
+source_set("raw_logging_internal") {
+}
+source_set("attributes_test") {
+}
+source_set("iterator_traits_test") {
+}
+source_set("nullability_default_nonnull_test") {
+}
+source_set("poison_test") {
+}
+source_set("tracing_internal_strong_test") {
+}
+source_set("tracing_internal_weak_test") {
+}
+source_set("endian") {
+}
+source_set("nullability_traits_test") {
+}
+source_set("raw_logging_test") {
+}
+source_set("sysinfo_test") {
+}
+source_set("thread_identity_test") {
+}
--- a/build/linux/unbundle/absl_container.gn
+++ b/build/linux/unbundle/absl_container.gn
@@ -129,3 +129,13 @@ source_set("raw_hash_set_test") {
 }
 source_set("sample_element_size_test") {
 }
+source_set("layout") {
+}
+source_set("node_hash_map_test") {
+}
+source_set("node_hash_set_test") {
+}
+source_set("raw_hash_set_resize_impl_test") {
+}
+source_set("hashtablez_sampler") {
+}
--- a/build/linux/unbundle/absl_debugging.gn
+++ b/build/linux/unbundle/absl_debugging.gn
@@ -50,3 +50,9 @@ source_set("demangle_rust_test") {
 }
 source_set("stacktrace_test") {
 }
+source_set("bounded_utf8_length_sequence_test") {
+}
+source_set("decode_rust_punycode_test") {
+}
+source_set("utf8_for_code_point_test") {
+}
--- a/build/linux/unbundle/absl_flags.gn
+++ b/build/linux/unbundle/absl_flags.gn
@@ -89,3 +89,5 @@ source_set("usage") {
 
 source_set("flag_test") {
 }
+source_set("marshalling") {
+}
--- a/build/linux/unbundle/absl_functional.gn
+++ b/build/linux/unbundle/absl_functional.gn
@@ -46,8 +46,19 @@ source_set("function_ref") {
   public_configs = [ ":system_absl_function_ref" ]
 }
 
+pkg_config("system_absl_overload") {
+  packages = [ "absl_overload" ]
+}
+
+shim_headers("overload_shim") {
+  root_path = "."
+  prefix = "absl/functional/"
+  headers = [ "overload.h" ]
+}
+
 source_set("overload") {
-  # Dummy â€” unavailable with abseil 202308 and chromium 122 does not use it
+  deps = [ ":overload_shim" ]
+  public_configs = [ ":system_absl_overload" ]
 }
 
 source_set("any_invocable_test") {
--- a/build/linux/unbundle/absl_log.gn
+++ b/build/linux/unbundle/absl_log.gn
@@ -138,3 +138,11 @@ source_set("stripping_test") {
 }
 source_set("vlog_is_on_test") {
 }
+source_set("absl_vlog_is_on") {
+}
+source_set("log_entry") {
+}
+source_set("log_sink") {
+}
+source_set("log_sink_registry") {
+}
--- a/build/linux/unbundle/absl_log_internal.gn
+++ b/build/linux/unbundle/absl_log_internal.gn
@@ -2,3 +2,5 @@ source_set("fnmatch_test") {
 }
 source_set("stderr_log_sink_test") {
 }
+source_set("structured_proto_test") {
+}
--- a/build/linux/unbundle/absl_random.gn
+++ b/build/linux/unbundle/absl_random.gn
@@ -62,3 +62,7 @@ group("distributions_test") {
 }
 group("mock_distributions_test") {
 }
+source_set("seed_gen_exception") {
+}
+source_set("mocking_bit_gen") {
+}
--- a/build/linux/unbundle/absl_strings.gn
+++ b/build/linux/unbundle/absl_strings.gn
@@ -44,6 +44,8 @@ shim_headers("strings_shim") {
     "string_view.h",
     "strip.h",
     "substitute.h",
+    "has_absl_stringify.h",
+    "has_ostream_operator.h",
   ]
 }
 
@@ -136,3 +138,13 @@ source_set("str_replace_test") {
 }
 source_set("string_view_test") {
 }
+source_set("charset") {
+}
+source_set("cord_test") {
+}
+source_set("cordz_handle_test") {
+}
+source_set("cordz_sample_token_test") {
+}
+source_set("str_cat_test") {
+}
--- a/build/linux/unbundle/absl_synchronization.gn
+++ b/build/linux/unbundle/absl_synchronization.gn
@@ -25,3 +25,11 @@ source_set("kernel_timeout_internal_test
 }
 source_set("waiter_test") {
 }
+source_set("barrier_test") {
+}
+source_set("graphcycles_test") {
+}
+source_set("mutex_test") {
+}
+source_set("per_thread_sem_test") {
+}
--- a/third_party/protobuf/src/google/protobuf/repeated_field.h
+++ b/third_party/protobuf/src/google/protobuf/repeated_field.h
@@ -33,6 +33,7 @@
 #include <utility>
 
 #include "absl/base/attributes.h"
+#include "absl/base/dynamic_annotations.h"
 #include "absl/base/optimization.h"
 #include "absl/log/absl_check.h"
 #include "absl/meta/type_traits.h"
--- a/third_party/re2/src/re2/dfa.cc
+++ b/third_party/re2/src/re2/dfa.cc
@@ -1015,7 +1015,7 @@ void DFA::RunWorkqOnByte(Workq* oldq, Wo
 DFA::State* DFA::RunStateOnByteUnlocked(State* state, int c) {
   // Keep only one RunStateOnByte going
   // even if the DFA is being run by multiple threads.
-  absl::MutexLock l(mutex_);
+  absl::MutexLock l(&mutex_);
   return RunStateOnByte(state, c);
 }
 
@@ -1267,7 +1267,7 @@ DFA::StateSaver::~StateSaver() {
 DFA::State* DFA::StateSaver::Restore() {
   if (is_special_)
     return special_;
-  absl::MutexLock l(dfa_->mutex_);
+  absl::MutexLock l(&dfa_->mutex_);
   State* s = dfa_->CachedState(inst_, ninst_, flag_);
   if (s == NULL)
     ABSL_LOG(DFATAL) << "StateSaver failed to restore state.";
@@ -1730,7 +1730,7 @@ bool DFA::AnalyzeSearchHelper(SearchPara
   if (start != NULL)
     return true;
 
-  absl::MutexLock l(mutex_);
+  absl::MutexLock l(&mutex_);
   start = info->start.load(std::memory_order_relaxed);
   if (start != NULL)
     return true;
@@ -2050,7 +2050,7 @@ bool DFA::PossibleMatchRange(std::string
   // Build minimum prefix.
   State* s = params.start;
   min->clear();
-  absl::MutexLock lock(mutex_);
+  absl::MutexLock lock(&mutex_);
   for (int i = 0; i < maxlen; i++) {
     if (previously_visited_states[s] > kMaxEltRepetitions)
       break;
--- a/third_party/re2/src/re2/regexp.cc
+++ b/third_party/re2/src/re2/regexp.cc
@@ -95,7 +95,7 @@ int Regexp::Ref() {
   if (ref_ < kMaxRef)
     return ref_;
 
-  absl::MutexLock l(*ref_mutex());
+  absl::MutexLock l(ref_mutex());
   return (*ref_map())[this];
 }
 
@@ -108,7 +108,7 @@ Regexp* Regexp::Incref() {
     });
 
     // Store ref count in overflow map.
-    absl::MutexLock l(*ref_mutex());
+    absl::MutexLock l(ref_mutex());
     if (ref_ == kMaxRef) {
       // already overflowed
       (*ref_map())[this]++;
@@ -128,7 +128,7 @@ Regexp* Regexp::Incref() {
 void Regexp::Decref() {
   if (ref_ == kMaxRef) {
     // Ref count is stored in overflow map.
-    absl::MutexLock l(*ref_mutex());
+    absl::MutexLock l(ref_mutex());
     int r = (*ref_map())[this] - 1;
     if (r < kMaxRef) {
       ref_ = static_cast<uint16_t>(r);
