--- a/build/linux/unbundle/absl_algorithm.gn
+++ b/build/linux/unbundle/absl_algorithm.gn
@@ -20,3 +20,5 @@ source_set("algorithm_test") {
 }
 source_set("container_test") {
 }
+source_set("algorithm") {
+}
--- a/build/linux/unbundle/absl_base.gn
+++ b/build/linux/unbundle/absl_base.gn
@@ -103,3 +103,35 @@ source_set("nullability_test") {
 }
 source_set("prefetch_test") {
 }
+source_set("dynamic_annotations") {
+}
+source_set("fast_type_id") {
+}
+source_set("log_severity") {
+}
+source_set("raw_logging_internal") {
+}
+source_set("attributes_test") {
+}
+source_set("iterator_traits_test") {
+}
+source_set("nullability_default_nonnull_test") {
+}
+source_set("poison_test") {
+}
+source_set("tracing_internal_strong_test") {
+}
+source_set("tracing_internal_weak_test") {
+}
+source_set("endian") {
+}
+source_set("nullability_traits_test") {
+}
+source_set("raw_logging_test") {
+}
+source_set("sysinfo_test") {
+}
+source_set("thread_identity_test") {
+}
+source_set("casts_test") {
+}
--- a/build/linux/unbundle/absl_container.gn
+++ b/build/linux/unbundle/absl_container.gn
@@ -129,3 +129,15 @@ source_set("raw_hash_set_test") {
 }
 source_set("sample_element_size_test") {
 }
+source_set("layout") {
+}
+source_set("node_hash_map_test") {
+}
+source_set("node_hash_set_test") {
+}
+source_set("raw_hash_set_resize_impl_test") {
+}
+source_set("hashtablez_sampler") {
+}
+source_set("hash_container_defaults") {
+}
--- a/build/linux/unbundle/absl_debugging.gn
+++ b/build/linux/unbundle/absl_debugging.gn
@@ -50,3 +50,9 @@ source_set("demangle_rust_test") {
 }
 source_set("stacktrace_test") {
 }
+source_set("bounded_utf8_length_sequence_test") {
+}
+source_set("decode_rust_punycode_test") {
+}
+source_set("utf8_for_code_point_test") {
+}
--- a/build/linux/unbundle/absl_flags.gn
+++ b/build/linux/unbundle/absl_flags.gn
@@ -89,3 +89,5 @@ source_set("usage") {
 
 source_set("flag_test") {
 }
+source_set("marshalling") {
+}
--- a/build/linux/unbundle/absl_functional.gn
+++ b/build/linux/unbundle/absl_functional.gn
@@ -46,8 +46,19 @@ source_set("function_ref") {
   public_configs = [ ":system_absl_function_ref" ]
 }
 
+pkg_config("system_absl_overload") {
+  packages = [ "absl_overload" ]
+}
+
+shim_headers("overload_shim") {
+  root_path = "."
+  prefix = "absl/functional/"
+  headers = [ "overload.h" ]
+}
+
 source_set("overload") {
-  # Dummy â€” unavailable with abseil 202308 and chromium 122 does not use it
+  deps = [ ":overload_shim" ]
+  public_configs = [ ":system_absl_overload" ]
 }
 
 source_set("any_invocable_test") {
--- a/build/linux/unbundle/absl_hash.gn
+++ b/build/linux/unbundle/absl_hash.gn
@@ -20,5 +20,7 @@ source_set("hash_instantiated_test") {
 }
 source_set("hash_test") {
 }
+source_set("hash_testing") {
+}
 source_set("low_level_hash_test") {
 }
--- a/build/linux/unbundle/absl_log.gn
+++ b/build/linux/unbundle/absl_log.gn
@@ -138,3 +138,11 @@ source_set("stripping_test") {
 }
 source_set("vlog_is_on_test") {
 }
+source_set("absl_vlog_is_on") {
+}
+source_set("log_entry") {
+}
+source_set("log_sink") {
+}
+source_set("log_sink_registry") {
+}
--- a/build/linux/unbundle/absl_log_internal.gn
+++ b/build/linux/unbundle/absl_log_internal.gn
@@ -2,3 +2,5 @@ source_set("fnmatch_test") {
 }
 source_set("stderr_log_sink_test") {
 }
+source_set("structured_proto_test") {
+}
--- a/build/linux/unbundle/absl_random.gn
+++ b/build/linux/unbundle/absl_random.gn
@@ -62,3 +62,7 @@ group("distributions_test") {
 }
 group("mock_distributions_test") {
 }
+source_set("seed_gen_exception") {
+}
+source_set("mocking_bit_gen") {
+}
--- a/build/linux/unbundle/absl_strings.gn
+++ b/build/linux/unbundle/absl_strings.gn
@@ -44,6 +44,8 @@ shim_headers("strings_shim") {
     "string_view.h",
     "strip.h",
     "substitute.h",
+    "has_absl_stringify.h",
+    "has_ostream_operator.h",
   ]
 }
 
@@ -136,3 +138,17 @@ source_set("str_replace_test") {
 }
 source_set("string_view_test") {
 }
+source_set("charset") {
+}
+source_set("cord_test") {
+}
+source_set("cordz_handle_test") {
+}
+source_set("cordz_sample_token_test") {
+}
+source_set("str_cat_test") {
+}
+source_set("resize_and_overwrite_test") {
+}
+source_set("append_and_overwrite_test") {
+}
--- a/build/linux/unbundle/absl_synchronization.gn
+++ b/build/linux/unbundle/absl_synchronization.gn
@@ -25,3 +25,11 @@ source_set("kernel_timeout_internal_test
 }
 source_set("waiter_test") {
 }
+source_set("barrier_test") {
+}
+source_set("graphcycles_test") {
+}
+source_set("mutex_test") {
+}
+source_set("per_thread_sem_test") {
+}
--- a/components/proto_extras/proto_extras_lib.h
+++ b/components/proto_extras/proto_extras_lib.h
@@ -12,10 +12,8 @@
 #include "base/numerics/safe_conversions.h"
 #include "base/strings/string_number_conversions.h"
 #include "base/values.h"
+#include "third_party/abseil-cpp/absl/strings/cord.h"
 
-namespace absl {
-class Cord;
-}  // namespace absl
 
 namespace google::protobuf {
 class MessageLite;
--- a/net/base/url_search_params_view.cc
+++ b/net/base/url_search_params_view.cc
@@ -80,17 +80,25 @@ void UrlSearchParamsView::Sort() {
   // actual order itself, it doesn't matter.
   std::ranges::stable_sort(params_, std::less<>(), &KeyValue::unescaped_key);
 }
-
+template <typename T, size_t N, typename A, typename Predicate>
+constexpr typename absl::InlinedVector<T, N, A>::size_type erase_if(
+    absl::InlinedVector<T, N, A>& v, Predicate pred) {
+  const auto it = std::remove_if(v.begin(), v.end(), std::move(pred));
+  const auto removed = static_cast<typename absl::InlinedVector<T, N, A>::size_type>(
+      std::distance(it, v.end()));
+  v.erase(it, v.end());
+  return removed;
+}
 void UrlSearchParamsView::DeleteAllWithNames(
     const base::flat_set<std::string>& names) {
-  absl::erase_if(params_, [&names](const KeyValue& key_value) {
+  erase_if(params_, [&names](const KeyValue& key_value) {
     return names.contains(key_value.unescaped_key);
   });
 }
 
 void UrlSearchParamsView::DeleteAllExceptWithNames(
     const base::flat_set<std::string>& names) {
-  absl::erase_if(params_, [&names](const KeyValue& key_value) {
+  erase_if(params_, [&names](const KeyValue& key_value) {
     return !names.contains(key_value.unescaped_key);
   });
 }
--- a/net/third_party/quiche/src/quiche/quic/core/crypto/crypto_secret_boxer.cc
+++ b/net/third_party/quiche/src/quiche/quic/core/crypto/crypto_secret_boxer.cc
@@ -68,7 +68,7 @@ bool CryptoSecretBoxer::SetKeys(const st
     new_state->ctxs.push_back(std::move(ctx));
   }
 
-  absl::WriterMutexLock l(lock_);
+  absl::WriterMutexLock l(&lock_);
   state_ = std::move(new_state);
   return true;
 }
@@ -95,7 +95,7 @@ std::string CryptoSecretBoxer::Box(QuicR
 
   size_t bytes_written;
   {
-    absl::ReaderMutexLock l(lock_);
+    absl::ReaderMutexLock l(&lock_);
     if (!EVP_AEAD_CTX_seal(state_->ctxs[0].get(), out, &bytes_written, out_len,
                            nonce, kSIVNonceSize,
                            reinterpret_cast<const uint8_t*>(plaintext.data()),
@@ -126,7 +126,7 @@ bool CryptoSecretBoxer::Unbox(absl::stri
 
   bool ok = false;
   {
-    absl::ReaderMutexLock l(lock_);
+    absl::ReaderMutexLock l(&lock_);
     for (const bssl::UniquePtr<EVP_AEAD_CTX>& ctx : state_->ctxs) {
       size_t bytes_written;
       if (EVP_AEAD_CTX_open(
--- a/net/third_party/quiche/src/quiche/quic/core/crypto/quic_crypto_server_config.cc
+++ b/net/third_party/quiche/src/quiche/quic/core/crypto/quic_crypto_server_config.cc
@@ -441,7 +441,7 @@ std::unique_ptr<CryptoHandshakeMessage>
   }
 
   {
-    absl::WriterMutexLock locked(configs_lock_);
+    absl::WriterMutexLock locked(&configs_lock_);
     if (configs_.find(config->id) != configs_.end()) {
       QUIC_LOG(WARNING) << "Failed to add config because another with the same "
                            "server config id already exists: "
@@ -504,7 +504,7 @@ bool QuicCryptoServerConfig::SetConfigs(
 
   QUIC_LOG(INFO) << "Updating configs:";
 
-  absl::WriterMutexLock locked(configs_lock_);
+  absl::WriterMutexLock locked(&configs_lock_);
   ConfigMap new_configs;
 
   for (const quiche::QuicheReferenceCountedPointer<Config>& config :
@@ -555,7 +555,7 @@ void QuicCryptoServerConfig::SetSourceAd
 }
 
 std::vector<std::string> QuicCryptoServerConfig::GetConfigIds() const {
-  absl::ReaderMutexLock locked(configs_lock_);
+  absl::ReaderMutexLock locked(&configs_lock_);
   std::vector<std::string> scids;
   for (auto it = configs_.begin(); it != configs_.end(); ++it) {
     scids.push_back(it->first);
@@ -1126,21 +1126,21 @@ bool QuicCryptoServerConfig::GetCurrentC
     const QuicWallTime& now, absl::string_view requested_scid,
     quiche::QuicheReferenceCountedPointer<Config> old_primary_config,
     Configs* configs) const {
-  absl::ReaderMutexLock locked(configs_lock_);
+  absl::ReaderMutexLock locked(&configs_lock_);
 
   if (!primary_config_) {
     return false;
   }
 
   if (IsNextConfigReady(now)) {
-    configs_lock_.unlock_shared();
-    configs_lock_.lock();
+    configs_lock_.ReaderUnlock();
+    configs_lock_.WriterLock();
     SelectNewPrimaryConfig(now);
     QUICHE_DCHECK(primary_config_.get());
     QUICHE_DCHECK_EQ(configs_.find(primary_config_->id)->second.get(),
                      primary_config_.get());
-    configs_lock_.unlock();
-    configs_lock_.lock_shared();
+    configs_lock_.WriterUnlock();
+    configs_lock_.ReaderLock();
   }
 
   if (old_primary_config != nullptr) {
@@ -1362,7 +1362,7 @@ void QuicCryptoServerConfig::BuildServer
   std::string serialized;
   std::string source_address_token;
   {
-    absl::ReaderMutexLock locked(configs_lock_);
+    absl::ReaderMutexLock locked(&configs_lock_);
     serialized = primary_config_->serialized;
     source_address_token = NewSourceAddressToken(
         *primary_config_->source_address_token_boxer,
@@ -1720,7 +1720,7 @@ void QuicCryptoServerConfig::set_enable_
 
 void QuicCryptoServerConfig::AcquirePrimaryConfigChangedCb(
     std::unique_ptr<PrimaryConfigChangedCallback> cb) {
-  absl::WriterMutexLock locked(configs_lock_);
+  absl::WriterMutexLock locked(&configs_lock_);
   primary_config_changed_cb_ = std::move(cb);
 }
 
@@ -1761,7 +1761,7 @@ std::string QuicCryptoServerConfig::NewS
 }
 
 int QuicCryptoServerConfig::NumberOfConfigs() const {
-  absl::ReaderMutexLock locked(configs_lock_);
+  absl::ReaderMutexLock locked(&configs_lock_);
   return configs_.size();
 }
 
--- a/third_party/abseil-cpp/absl/base/casts.h
+++ b/third_party/abseil-cpp/absl/base/casts.h
@@ -94,7 +94,7 @@ constexpr std::enable_if_t<
     !type_traits_internal::IsView<std::enable_if_t<
         !std::is_reference_v<To>, std::remove_cv_t<To>>>::value,
     To>
-implicit_cast(absl::type_identity_t<To> to) {
+implicit_cast(std::type_identity_t<To> to) {
   return to;
 }
 template <typename To>
@@ -102,13 +102,13 @@ constexpr std::enable_if_t<
     type_traits_internal::IsView<std::enable_if_t<!std::is_reference_v<To>,
                                                   std::remove_cv_t<To>>>::value,
     To>
-implicit_cast(absl::type_identity_t<To> to ABSL_ATTRIBUTE_LIFETIME_BOUND) {
+implicit_cast(std::type_identity_t<To> to ABSL_ATTRIBUTE_LIFETIME_BOUND) {
   return to;
 }
 template <typename To>
 constexpr std::enable_if_t<std::is_reference_v<To>, To> implicit_cast(
-    absl::type_identity_t<To> to ABSL_ATTRIBUTE_LIFETIME_BOUND) {
-  return std::forward<absl::type_identity_t<To>>(to);
+    std::type_identity_t<To> to ABSL_ATTRIBUTE_LIFETIME_BOUND) {
+  return std::forward<std::type_identity_t<To>>(to);
 }
 
 // bit_cast()
--- a/third_party/protobuf/src/google/protobuf/repeated_field.h
+++ b/third_party/protobuf/src/google/protobuf/repeated_field.h
@@ -33,6 +33,7 @@
 #include <utility>
 
 #include "absl/base/attributes.h"
+#include "absl/base/dynamic_annotations.h"
 #include "absl/base/optimization.h"
 #include "absl/log/absl_check.h"
 #include "absl/meta/type_traits.h"
--- a/third_party/tflite/src/tensorflow/lite/experimental/acceleration/mini_benchmark/mini_benchmark.cc
+++ b/third_party/tflite/src/tensorflow/lite/experimental/acceleration/mini_benchmark/mini_benchmark.cc
@@ -57,14 +57,14 @@ std::unique_ptr<MiniBenchmark> CreateMin
 
 void MinibenchmarkImplementationRegistry::RegisterImpl(
     const std::string& name, CreatorFunction creator_function) {
-  absl::MutexLock lock(mutex_);
+  absl::MutexLock lock(&mutex_);
   factories_[name] = creator_function;
 }
 
 std::unique_ptr<MiniBenchmark> MinibenchmarkImplementationRegistry::CreateImpl(
     const std::string& name, const MinibenchmarkSettings& settings,
     const std::string& model_namespace, const std::string& model_id) {
-  absl::MutexLock lock(mutex_);
+  absl::MutexLock lock(&mutex_);
   auto it = factories_.find(name);
   return (it != factories_.end())
              ? it->second(settings, model_namespace, model_id)
--- a/v8/src/base/platform/mutex.cc
+++ b/v8/src/base/platform/mutex.cc
@@ -60,17 +60,17 @@ Mutex::Mutex() {
 Mutex::~Mutex() { DCHECK_EQ(0, level_); }
 
 void Mutex::Lock() ABSL_NO_THREAD_SAFETY_ANALYSIS {
-  native_handle_.lock();
+  native_handle_.Lock();
   AssertUnheldAndMark();
 }
 
 void Mutex::Unlock() ABSL_NO_THREAD_SAFETY_ANALYSIS {
   AssertHeldAndUnmark();
-  native_handle_.unlock();
+  native_handle_.Unlock();
 }
 
 bool Mutex::TryLock() ABSL_NO_THREAD_SAFETY_ANALYSIS {
-  if (!native_handle_.try_lock()) return false;
+  if (!native_handle_.TryLock()) return false;
   AssertUnheldAndMark();
   return true;
 }
