--- a/chrome/browser/ui/webui/side_panel/read_anything/read_anything_screenshotter.cc
+++ b/chrome/browser/ui/webui/side_panel/read_anything/read_anything_screenshotter.cc
@@ -19,7 +19,7 @@
 #include "mojo/public/cpp/base/proto_wrapper.h"
 #include "third_party/skia/include/core/SkImage.h"
 #include "third_party/skia/include/core/SkStream.h"
-#include "third_party/skia/include/encode/SkPngRustEncoder.h"
+#include "third_party/skia/include/encode/SkPngEncoder.h"
 #include "ui/gfx/geometry/rect.h"
 
 constexpr size_t kMaxScreenshotFileSize = 50 * 1000L * 1000L;  // 50 MB.
@@ -73,7 +73,7 @@ void WriteBitmapToPng(const SkBitmap& bi
     return;
   }
   bool success_encode =
-      SkPngRustEncoder::Encode(&out_file, cropped_pixmap, /*options=*/{});
+      SkPngEncoder::Encode(&out_file, cropped_pixmap, /*options=*/{});
   if (success_encode) {
     VLOG(2) << "Wrote debug file: " << screenshot_filepath;
   } else {
--- a/components/paint_preview/common/serial_utils.cc
+++ b/components/paint_preview/common/serial_utils.cc
@@ -15,7 +15,7 @@
 #include "third_party/skia/include/codec/SkCodec.h"
 #include "third_party/skia/include/codec/SkGifDecoder.h"
 #include "third_party/skia/include/codec/SkJpegDecoder.h"
-#include "third_party/skia/include/codec/SkPngRustDecoder.h"
+#include "third_party/skia/include/codec/SkPngDecoder.h"
 #include "third_party/skia/include/codec/SkWebpDecoder.h"
 #include "third_party/skia/include/core/SkCanvas.h"
 #include "third_party/skia/include/core/SkData.h"
@@ -135,7 +135,7 @@ static bool is_supported_codec(sk_sp<SkD
   CHECK(data);
   return SkBmpDecoder::IsBmp(data->data(), data->size()) ||
          SkGifDecoder::IsGif(data->data(), data->size()) ||
-         SkPngRustDecoder::IsPng(data->data(), data->size()) ||
+         SkPngDecoder::IsPng(data->data(), data->size()) ||
          SkJpegDecoder::IsJpeg(data->data(), data->size()) ||
          SkWebpDecoder::IsWebp(data->data(), data->size());
 }
@@ -203,8 +203,8 @@ sk_sp<SkImage> DeserializeImage(const vo
         codec->getInfo().makeAlphaType(kPremul_SkAlphaType);
     return std::get<0>(codec->getImage(targetInfo));
   };
-  if (SkPngRustDecoder::IsPng(bytes, length)) {
-    return get_image(SkPngRustDecoder::Decode(
+  if (SkPngDecoder::IsPng(bytes, length)) {
+    return get_image(SkPngDecoder::Decode(
         std::make_unique<SkMemoryStream>(std::move(data)), nullptr));
   }
   if (SkBmpDecoder::IsBmp(bytes, length)) {
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -188,9 +188,6 @@ config("skia_library_config") {
     defines += [ "SK_CODEC_DECODES_ICO" ]
   }
 
-  if (use_blink) {
-    defines += [ "SK_TYPEFACE_FACTORY_FONTATIONS" ]
-  }
   if (use_blink && !use_system_freetype) {
     defines += [ "SK_FREETYPE_MINIMUM_RUNTIME_VERSION_IS_BUILD_VERSION" ]
   }
@@ -353,10 +350,8 @@ component("skia") {
   public += skia_utils_chromium
   public += skia_discardable_memory_chromium
   public += skia_codec_public
-  public += skia_codec_rust_png_public
   public += skia_encode_public
   public += skia_encode_png_public
-  public += skia_encode_rust_png_public
   public += skia_encode_webp_public
 
   # The imported Skia gni source paths are made absolute by gn.
@@ -367,13 +362,11 @@ component("skia") {
   sources += skia_codec_shared
   sources += skia_codec_png_base
   sources += skia_codec_libpng_srcs
-  sources += skia_codec_rust_png
   sources += skia_utils_private
   sources += skia_xps_sources
   sources += skia_encode_srcs
   sources += skia_encode_png_base
   sources += skia_encode_libpng_srcs
-  sources += skia_encode_rust_png_srcs
   sources += skia_encode_webp_srcs
 
   sources += [
@@ -436,8 +429,6 @@ component("skia") {
       public += skia_ports_fontmgr_empty_public
     }
     sources += skia_ports_typeface_proxy_sources
-    sources += skia_ports_typeface_fontations_sources
-    sources += skia_ports_fontmgr_fontations_sources
 
     # Fontations Rust/C++ bridge interfaces.
     deps += [
--- a/skia/ext/codec_utils.cc
+++ b/skia/ext/codec_utils.cc
@@ -8,30 +8,36 @@
 #include "base/check.h"
 #include "skia/ext/skia_utils_base.h"
 #include "third_party/skia/include/codec/SkCodec.h"
-#include "third_party/skia/include/codec/SkPngRustDecoder.h"
+#include "third_party/skia/include/codec/SkPngDecoder.h"
 #include "third_party/skia/include/core/SkData.h"
 #include "third_party/skia/include/core/SkImage.h"
 #include "third_party/skia/include/core/SkPixmap.h"
 #include "third_party/skia/include/core/SkStream.h"
-#include "third_party/skia/include/encode/SkPngRustEncoder.h"
+#include "third_party/skia/include/encode/SkPngEncoder.h"
 
 namespace skia {
 
 namespace {
 
 sk_sp<SkData> EncodePngAsSkData(const SkPixmap& src,
-                                const SkPngRustEncoder::Options& options) {
+                                const SkPngEncoder::Options& options) {
   SkDynamicMemoryWStream stream;
-  if (!SkPngRustEncoder::Encode(&stream, src, options)) {
+  if (!SkPngEncoder::Encode(&stream, src, options)) {
     return nullptr;
   }
   return stream.detachAsData();
 }
 
-sk_sp<SkData> EncodePngAsSkData(
-    GrDirectContext* context,
-    const SkImage* src,
-    SkPngRustEncoder::CompressionLevel compression_level) {
+}  // namespace
+
+sk_sp<SkData> EncodePngAsSkData(const SkPixmap& src) {
+  const SkPngEncoder::Options kDefaultOptions = {};
+  return EncodePngAsSkData(src, kDefaultOptions);
+}
+
+sk_sp<SkData> EncodePngAsSkData(GrDirectContext* context,
+                                const SkImage* src,
+                                int zlib_compression_level) {
   if (!src) {
     return nullptr;
   }
@@ -47,27 +53,16 @@ sk_sp<SkData> EncodePngAsSkData(
   // `peekPixels` should always succeed for raster images.
   CHECK(success);
 
-  const SkPngRustEncoder::Options options = {.fCompressionLevel =
-                                                 compression_level};
+  const SkPngEncoder::Options options = {.fZLibLevel = zlib_compression_level};
   return EncodePngAsSkData(pixmap, options);
 }
 
-}  // namespace
-
-sk_sp<SkData> EncodePngAsSkData(const SkPixmap& src) {
-  const SkPngRustEncoder::Options kDefaultOptions = {};
-  return EncodePngAsSkData(src, kDefaultOptions);
-}
-
 sk_sp<SkData> EncodePngAsSkData(GrDirectContext* context, const SkImage* src) {
-  return EncodePngAsSkData(context, src,
-                           SkPngRustEncoder::CompressionLevel::kMedium);
-}
+  // This is the default level in
+  // `third_party/skia/include/encode/SkPngEncoder.h`.
+  const int kDefaultZlibCompressionLevel = 6;
 
-sk_sp<SkData> FastEncodePngAsSkData(GrDirectContext* context,
-                                    const SkImage* src) {
-  return EncodePngAsSkData(context, src,
-                           SkPngRustEncoder::CompressionLevel::kLow);
+  return EncodePngAsSkData(context, src, kDefaultZlibCompressionLevel);
 }
 
 std::string EncodePngAsDataUri(const SkPixmap& src) {
@@ -80,7 +75,8 @@ std::string EncodePngAsDataUri(const SkP
 }
 
 void EnsurePNGDecoderRegistered() {
-  SkCodecs::Register(SkPngRustDecoder::Decoder());
+  SkCodecs::Register(SkPngDecoder::Decoder());
 }
 
 }  // namespace skia
+
--- a/skia/ext/codec_utils.h
+++ b/skia/ext/codec_utils.h
@@ -19,8 +19,9 @@ namespace skia {
 SK_API sk_sp<SkData> EncodePngAsSkData(const SkPixmap& src);
 SK_API sk_sp<SkData> EncodePngAsSkData(GrDirectContext* context,
                                        const SkImage* src);
-SK_API sk_sp<SkData> FastEncodePngAsSkData(GrDirectContext* context,
-                                           const SkImage* src);
+SK_API sk_sp<SkData> EncodePngAsSkData(GrDirectContext* context,
+                                       const SkImage* src,
+                                       int zlib_compression_level);
 SK_API std::string EncodePngAsDataUri(const SkPixmap& src);
 
 // This is not thread safe and should only be called via startup
@@ -29,3 +30,4 @@ SK_API void EnsurePNGDecoderRegistered()
 }  // namespace skia
 
 #endif  // SKIA_EXT_CODEC_UTILS_H_
+
--- a/skia/ext/font_utils.cc
+++ b/skia/ext/font_utils.cc
@@ -66,9 +66,7 @@ static sk_sp<SkFontMgr> fontmgr_factory(
   return SkFontMgr_New_CoreText(nullptr);
 #elif BUILDFLAG(IS_CHROMEOS) || BUILDFLAG(IS_LINUX)
   sk_sp<SkFontConfigInterface> fci(SkFontConfigInterface::RefGlobal());
-  return fci ? SkFontMgr_New_FCI(std::move(fci),
-                                 SkFontScanner_Make_Fontations())
-             : nullptr;
+  return fci ? SkFontMgr_New_FCI(std::move(fci),SkFontScanner_Make_FreeType()) : nullptr;
 #elif BUILDFLAG(IS_FUCHSIA)
   fuchsia::fonts::ProviderSyncPtr provider;
   base::ComponentContextForProcess()->svc()->Connect(provider.NewRequest());
--- a/third_party/blink/renderer/core/html/canvas/canvas_async_blob_creator.cc
+++ b/third_party/blink/renderer/core/html/canvas/canvas_async_blob_creator.cc
@@ -38,7 +38,7 @@
 #include "third_party/blink/renderer/platform/wtf/text/base64.h"
 #include "third_party/blink/renderer/platform/wtf/text/strcat.h"
 #include "third_party/skia/include/core/SkSurface.h"
-#include "third_party/skia/include/encode/SkPngRustEncoder.h"
+#include "third_party/skia/include/encode/SkPngEncoder.h"
 
 namespace blink {
 
@@ -605,8 +605,10 @@ bool CanvasAsyncBlobCreator::InitializeE
     // TODO(zakerinasab): Progressive encoding on webp image formats
     // (crbug.com/571399)
     DCHECK_EQ(kMimeTypePng, mime_type_);
-    encoder_ = ImageEncoder::Create(&encoded_image_, src_data_,
-                                    SkPngRustEncoder::CompressionLevel::kLow);
+    SkPngEncoder::Options options;
+    options.fFilterFlags = SkPngEncoder::FilterFlag::kSub;
+    options.fZLibLevel = 3;
+    encoder_ = ImageEncoder::Create(&encoded_image_, src_data_, options);
   }
 
   return encoder_.get();
--- a/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.cc
+++ b/third_party/blink/renderer/platform/fonts/skia/sktypeface_factory.cc
@@ -27,7 +27,7 @@ sk_sp<SkTypeface> SkTypeface_Factory::Fr
   SkFontConfigInterface::FontIdentity font_identity;
   font_identity.fID = config_id;
   font_identity.fTTCIndex = ttc_index;
-  return fci->makeTypeface(font_identity, SkFontMgr_New_Fontations_Empty());
+  return fci->makeTypeface(font_identity, skia::DefaultFontMgr());
 #else
   NOTREACHED();
 #endif
@@ -39,8 +39,7 @@ sk_sp<SkTypeface> SkTypeface_Factory::Fr
     int ttc_index) {
 #if !BUILDFLAG(IS_WIN) && !BUILDFLAG(IS_ANDROID) && !BUILDFLAG(IS_FUCHSIA) && \
     !BUILDFLAG(IS_APPLE)
-  return SkFontMgr_New_Fontations_Empty()->makeFromFile(filename.c_str(),
-                                                        ttc_index);
+  return skia::DefaultFontMgr()->makeFromFile(filename.c_str(), ttc_index);
 #else
   NOTREACHED();
 #endif
--- a/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc
+++ b/third_party/blink/renderer/platform/fonts/web_font_typeface_factory.cc
@@ -11,7 +11,6 @@
 #include "third_party/blink/renderer/platform/fonts/font_cache.h"
 #include "third_party/blink/renderer/platform/fonts/opentype/font_format_check.h"
 #include "third_party/skia/include/core/SkTypeface.h"
-#include "third_party/skia/include/ports/SkTypeface_fontations.h"
 
 #if BUILDFLAG(IS_WIN)
 #include "third_party/blink/renderer/platform/fonts/win/dwrite_font_format_support.h"
@@ -37,11 +36,7 @@ bool IsWin() {
 }
 
 bool IsFreeTypeSystemRasterizer() {
-#if !BUILDFLAG(IS_WIN) && !BUILDFLAG(IS_APPLE)
   return true;
-#else
-  return false;
-#endif
 }
 
 sk_sp<SkTypeface> MakeTypefaceDefaultFontMgr(sk_sp<SkData> data) {
@@ -49,13 +44,7 @@ sk_sp<SkTypeface> MakeTypefaceDefaultFon
   return FontCache::Get().FontManager()->makeFromData(data, 0);
 #endif
 
-#if BUILDFLAG(IS_APPLE)
   return skia::DefaultFontMgr()->makeFromData(data, 0);
-#endif
-
-#if !(BUILDFLAG(IS_WIN) || BUILDFLAG(IS_APPLE))
-  return SkTypeface_Make_Fontations(data, SkFontArguments());
-#endif
 }
 
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_APPLE)
@@ -64,10 +53,6 @@ sk_sp<SkTypeface> MakeTypefaceFallback(s
 }
 #endif
 
-sk_sp<SkTypeface> MakeTypefaceFontations(sk_sp<SkData> data) {
-  return SkTypeface_Make_Fontations(data, SkFontArguments());
-}
-
 sk_sp<SkTypeface> MakeVariationsTypeface(
     sk_sp<SkData> data,
     const WebFontTypefaceFactory::FontInstantiator& instantiator) {
@@ -87,9 +72,6 @@ sk_sp<SkTypeface> MakeSbixTypeface(
     const WebFontTypefaceFactory::FontInstantiator& instantiator) {
   // If we're on a OS with FreeType as backend, or on Windows, where we used to
   // use FreeType for SBIX, switch to Fontations for SBIX.
-  if (IsFreeTypeSystemRasterizer() || IsWin()) {
-    return instantiator.make_fontations(data);
-  }
 
   // Remaining case, on Mac, CoreText can handle creating SBIX fonts.
   return instantiator.make_system(data);
@@ -98,29 +80,21 @@ sk_sp<SkTypeface> MakeSbixTypeface(
 sk_sp<SkTypeface> MakeColrV0Typeface(
     sk_sp<SkData> data,
     const WebFontTypefaceFactory::FontInstantiator& instantiator) {
-  if (IsWin()) {
     // On Windows Skia's DirectWrite
     // backend handles COLRv0.
     return instantiator.make_system(data);
-  }
-  return instantiator.make_fontations(data);
 }
 
 sk_sp<SkTypeface> MakeColrV0VariationsTypeface(
     sk_sp<SkData> data,
     const WebFontTypefaceFactory::FontInstantiator& instantiator) {
-#if BUILDFLAG(IS_WIN)
-  if (DWriteVersionSupportsVariations()) {
     return instantiator.make_system(data);
-  }
-#endif
-  return instantiator.make_fontations(data);
 }
 
 sk_sp<SkTypeface> MakeFontationsFallbackPreferred(
     sk_sp<SkData> data,
     const WebFontTypefaceFactory::FontInstantiator& instantiator) {
-  return instantiator.make_fontations(data);
+  return instantiator.make_system(data);
 }
 
 }  // namespace
@@ -130,7 +104,6 @@ bool WebFontTypefaceFactory::CreateTypef
   const FontFormatCheck format_check(data);
   const FontInstantiator instantiator = {
       MakeTypefaceDefaultFontMgr,
-      MakeTypefaceFontations,
 #if BUILDFLAG(IS_WIN) || BUILDFLAG(IS_APPLE)
       MakeTypefaceFallback,
 #endif
--- a/third_party/blink/renderer/platform/graphics/canvas_hibernation_handler.cc
+++ b/third_party/blink/renderer/platform/graphics/canvas_hibernation_handler.cc
@@ -30,7 +30,7 @@
 #include "third_party/blink/renderer/platform/wtf/functional.h"
 #include "third_party/blink/renderer/platform/wtf/hash_set.h"
 #include "third_party/skia/include/codec/SkCodec.h"
-#include "third_party/skia/include/codec/SkPngRustDecoder.h"
+#include "third_party/skia/include/codec/SkPngDecoder.h"
 #include "third_party/skia/include/core/SkAlphaType.h"
 #include "third_party/skia/include/core/SkData.h"
 #include "third_party/skia/include/core/SkImage.h"
@@ -238,11 +238,12 @@ void CanvasHibernationHandler::Encode(
       break;
     case CompressionAlgorithm::kZstd: {
 #if BUILDFLAG(HAS_ZSTD_COMPRESSION)
-      // Do minimal PNG compression and then pass the result to ZSTD. This won't
-      // produce a valid PNG, but it doesn't matter, as we don't write it to
-      // disk, and restore it ourselves.
-      sk_sp<SkData> encoded_uncompressed =
-          skia::FastEncodePngAsSkData(nullptr, params->image.get());
+      // When the compression level is set to 0, no compression is done. Then we
+      // can pass the result to ZSTD. This won't produce a valid PNG, but it
+      // doesn't matter, as we don't write it to disk, and restore it ourselves.
+      constexpr int kZLibCompressionLevel = 0;
+      sk_sp<SkData> encoded_uncompressed = skia::EncodePngAsSkData(
+          nullptr, params->image.get(), kZLibCompressionLevel);
 
       TRACE_EVENT_BEGIN2("blink", "ZstdCompression", "original_size", 0, "size",
                          0);
@@ -328,13 +329,12 @@ sk_sp<SkImage> CanvasHibernationHandler:
     }
   }
 
-  CHECK(SkPngRustDecoder::IsPng(png_data->data(), png_data->size()));
+  CHECK(SkPngDecoder::IsPng(png_data->data(), png_data->size()));
 
   base::TimeTicks before = base::TimeTicks::Now();
   // Note: not discarding the encoded image.
   sk_sp<SkImage> image = nullptr;
-  std::unique_ptr<SkCodec> codec = SkPngRustDecoder::Decode(
-      std::make_unique<SkMemoryStream>(std::move(png_data)), nullptr);
+  std::unique_ptr<SkCodec> codec = SkPngDecoder::Decode(png_data, nullptr);
   if (codec) {
     image = std::get<0>(codec->getImage());
   }
--- a/third_party/blink/renderer/platform/graphics/picture_snapshot.cc
+++ b/third_party/blink/renderer/platform/graphics/picture_snapshot.cc
@@ -43,6 +43,7 @@
 #include "third_party/blink/renderer/platform/wtf/text/text_encoding.h"
 #include "third_party/skia/include/core/SkImage.h"
 #include "third_party/skia/include/core/SkPictureRecorder.h"
+#include "third_party/skia/include/encode/SkPngEncoder.h"
 #include "ui/gfx/geometry/rect_f.h"
 #include "ui/gfx/geometry/size.h"
 #include "ui/gfx/geometry/skia_conversions.h"
@@ -118,8 +119,10 @@ Vector<uint8_t> PictureSnapshot::Replay(
   bool peekResult = bitmap.peekPixels(&src);
   DCHECK(peekResult);
 
-  if (!ImageEncoder::Encode(&encoded_image, src,
-                            SkPngRustEncoder::CompressionLevel::kLow)) {
+  SkPngEncoder::Options options;
+  options.fFilterFlags = SkPngEncoder::FilterFlag::kSub;
+  options.fZLibLevel = 3;
+  if (!ImageEncoder::Encode(&encoded_image, src, options)) {
     return Vector<uint8_t>();
   }
 
--- a/third_party/blink/renderer/platform/image-decoders/png/png_image_decoder.cc
+++ b/third_party/blink/renderer/platform/image-decoders/png/png_image_decoder.cc
@@ -5,7 +5,7 @@
 #include "third_party/blink/renderer/platform/image-decoders/png/png_image_decoder.h"
 
 #include "third_party/blink/renderer/platform/wtf/text/atomic_string.h"
-#include "third_party/skia/include/codec/SkPngRustDecoder.h"
+#include "third_party/skia/include/codec/SkPngDecoder.h"
 #include "third_party/skia/include/core/SkStream.h"
 
 namespace blink {
@@ -25,7 +25,7 @@ std::unique_ptr<SkCodec> PngImageDecoder
     std::unique_ptr<SkStream> stream,
     SkCodec::Result* result) {
   std::unique_ptr<SkCodec> codec =
-      SkPngRustDecoder::Decode(std::move(stream), result);
+      SkPngDecoder::Decode(std::move(stream), result);
   return codec;
 }
 
--- a/third_party/blink/renderer/platform/image-encoders/image_encoder.cc
+++ b/third_party/blink/renderer/platform/image-encoders/image_encoder.cc
@@ -27,10 +27,9 @@ bool ImageEncoder::Encode(Vector<unsigne
 bool ImageEncoder::Encode(
     Vector<unsigned char>* dst,
     const SkPixmap& src,
-    SkPngRustEncoder::CompressionLevel compression_level) {
+    const SkPngEncoder::Options& options) {
   VectorWStream dst_stream(dst);
-  SkPngRustEncoder::Options options = {.fCompressionLevel = compression_level};
-  return SkPngRustEncoder::Encode(&dst_stream, src, options);
+  return SkPngEncoder::Encode(&dst_stream, src, options);
 }
 
 bool ImageEncoder::Encode(Vector<unsigned char>* dst,
@@ -59,7 +58,10 @@ bool ImageEncoder::Encode(Vector<unsigne
       return Encode(dst, src, options);
     }
     case kMimeTypePng: {
-      return Encode(dst, src, SkPngRustEncoder::CompressionLevel::kLow);
+      SkPngEncoder::Options options;
+      options.fFilterFlags = SkPngEncoder::FilterFlag::kSub;
+      options.fZLibLevel = 3;
+      return Encode(dst, src, options);
     }
   }
 }
@@ -81,11 +83,10 @@ std::unique_ptr<ImageEncoder> ImageEncod
 std::unique_ptr<ImageEncoder> ImageEncoder::Create(
     Vector<unsigned char>* dst,
     const SkPixmap& src,
-    SkPngRustEncoder::CompressionLevel compression_level) {
+    const SkPngEncoder::Options& options) {
   std::unique_ptr<ImageEncoder> image_encoder(new ImageEncoder(dst));
-  SkPngRustEncoder::Options options = {.fCompressionLevel = compression_level};
   image_encoder->encoder_ =
-      SkPngRustEncoder::Make(&image_encoder->dst_, src, options);
+      SkPngEncoder::Make(&image_encoder->dst_, src, options);
   if (!image_encoder->encoder_) {
     return nullptr;
   }
--- a/third_party/blink/renderer/platform/image-encoders/image_encoder.h
+++ b/third_party/blink/renderer/platform/image-encoders/image_encoder.h
@@ -12,7 +12,7 @@
 #include "third_party/blink/renderer/platform/wtf/vector.h"
 #include "third_party/skia/include/core/SkStream.h"
 #include "third_party/skia/include/encode/SkJpegEncoder.h"
-#include "third_party/skia/include/encode/SkPngRustEncoder.h"
+#include "third_party/skia/include/encode/SkPngEncoder.h"
 #include "third_party/skia/include/encode/SkWebpEncoder.h"
 
 namespace blink {
@@ -55,7 +55,7 @@ class PLATFORM_EXPORT ImageEncoder {
 
   static bool Encode(Vector<unsigned char>* dst,
                      const SkPixmap& src,
-                     SkPngRustEncoder::CompressionLevel);
+                     const SkPngEncoder::Options&);
 
   static bool Encode(Vector<unsigned char>* dst,
                      const SkPixmap& src,
@@ -75,7 +75,7 @@ class PLATFORM_EXPORT ImageEncoder {
   static std::unique_ptr<ImageEncoder> Create(
       Vector<unsigned char>* dst,
       const SkPixmap& src,
-      SkPngRustEncoder::CompressionLevel);
+      const SkPngEncoder::Options&);
 
   bool encodeRows(int numRows) { return encoder_->encodeRows(numRows); }
 
--- a/ui/gfx/codec/BUILD.gn
+++ b/ui/gfx/codec/BUILD.gn
@@ -21,6 +21,7 @@ component("codec") {
 
   deps = [
     "//skia",
+    "//third_party/zlib",
     "//ui/gfx:gfx_skia",
     "//ui/gfx/geometry",
   ]
--- a/ui/gfx/codec/png_codec.cc
+++ b/ui/gfx/codec/png_codec.cc
@@ -12,11 +12,11 @@
 #include "base/metrics/histogram_macros.h"
 #include "base/notreached.h"
 #include "base/strings/string_util.h"
-#include "third_party/skia/include/codec/SkPngRustDecoder.h"
+#include "third_party/skia/include/codec/SkPngDecoder.h"
 #include "third_party/skia/include/core/SkBitmap.h"
 #include "third_party/skia/include/core/SkColorType.h"
 #include "third_party/skia/include/core/SkUnPreMultiply.h"
-#include "third_party/skia/include/encode/SkPngRustEncoder.h"
+#include "third_party/skia/include/encode/SkPngEncoder.h"
 #include "ui/gfx/codec/vector_wstream.h"
 #include "ui/gfx/geometry/size.h"
 
@@ -34,7 +34,7 @@ namespace {
 
 std::unique_ptr<SkCodec> CreatePngDecoder(std::unique_ptr<SkStream> stream,
                                           SkCodec::Result* result) {
-  return SkPngRustDecoder::Decode(std::move(stream), result);
+  return SkPngDecoder::Decode(std::move(stream), result);
 }
 
 struct PreparationOutput {
@@ -170,7 +170,7 @@ SkBitmap PNGCodec::Decode(base::span<con
 
 namespace {
 
-void AddComments(SkPngRustEncoder::Options& options,
+void AddComments(SkPngEncoder::Options& options,
                  const std::vector<PNGCodec::Comment>& comments) {
   std::vector<const char*> comment_pointers;
   std::vector<size_t> comment_sizes;
@@ -188,14 +188,19 @@ void AddComments(SkPngRustEncoder::Optio
 std::optional<std::vector<uint8_t>> EncodeSkPixmap(
     const SkPixmap& src,
     const std::vector<PNGCodec::Comment>& comments,
-    SkPngRustEncoder::CompressionLevel compression_level) {
+    int zlib_level,
+    bool disable_filters) {
   std::vector<uint8_t> output;
   VectorWStream dst(&output);
 
-  SkPngRustEncoder::Options options;
+  SkPngEncoder::Options options;
   AddComments(options, comments);
-  options.fCompressionLevel = compression_level;
-  if (!SkPngRustEncoder::Encode(&dst, src, options)) {
+  options.fZLibLevel = zlib_level;
+  if (disable_filters) {
+    options.fFilterFlags = SkPngEncoder::FilterFlag::kNone;
+  }
+
+  if (!SkPngEncoder::Encode(&dst, src, options)) {
     return std::nullopt;
   }
 
@@ -206,7 +211,8 @@ std::optional<std::vector<uint8_t>> Enco
     const SkPixmap& src,
     bool discard_transparency,
     const std::vector<PNGCodec::Comment>& comments,
-    SkPngRustEncoder::CompressionLevel compression_level) {
+    int zlib_level,
+    bool disable_filters) {
   if (discard_transparency) {
     SkImageInfo opaque_info = src.info().makeAlphaType(kOpaque_SkAlphaType);
     SkBitmap copy;
@@ -223,7 +229,7 @@ std::optional<std::vector<uint8_t>> Enco
         src.readPixels(opaque_info.makeAlphaType(kUnpremul_SkAlphaType),
                        opaque_pixmap.writable_addr(), opaque_pixmap.rowBytes());
     DCHECK(success);
-    return EncodeSkPixmap(opaque_pixmap, comments, compression_level);
+    return EncodeSkPixmap(opaque_pixmap, comments, zlib_level, disable_filters);
   }
 
   // If the image's pixels are all opaque, encode the PNG as opaque, regardless
@@ -231,23 +237,24 @@ std::optional<std::vector<uint8_t>> Enco
   if (src.info().alphaType() != kOpaque_SkAlphaType && src.computeIsOpaque()) {
     SkPixmap opaque_pixmap{src.info().makeAlphaType(kOpaque_SkAlphaType),
                            src.addr(), src.rowBytes()};
-    return EncodeSkPixmap(opaque_pixmap, comments, compression_level);
+    return EncodeSkPixmap(opaque_pixmap, comments, zlib_level, disable_filters);
   }
 
   // Encode the PNG without any conversions.
-  return EncodeSkPixmap(src, comments, compression_level);
+  return EncodeSkPixmap(src, comments, zlib_level, disable_filters);
 }
 
-std::optional<std::vector<uint8_t>> EncodeSkBitmap(
-    const SkBitmap& input,
-    bool discard_transparency,
-    SkPngRustEncoder::CompressionLevel compression_level) {
+std::optional<std::vector<uint8_t>> EncodeSkBitmap(const SkBitmap& input,
+                                                   bool discard_transparency,
+                                                   int zlib_level,
+                                                   bool disable_filters) {
   SkPixmap src;
   if (!input.peekPixels(&src)) {
     return std::nullopt;
   }
   return EncodeSkPixmap(src, discard_transparency,
-                        std::vector<PNGCodec::Comment>(), compression_level);
+                        std::vector<PNGCodec::Comment>(), zlib_level,
+                        disable_filters);
 }
 
 }  // namespace
@@ -278,21 +285,21 @@ std::optional<std::vector<uint8_t>> PNGC
       SkImageInfo::Make(size.width(), size.height(), colorType, alphaType);
   SkPixmap src(info, input, row_byte_width);
   return EncodeSkPixmap(src, discard_transparency, comments,
-                        SkPngRustEncoder::CompressionLevel::kMedium);
+                        6, /*disable_filters=*/false);
 }
 
 std::optional<std::vector<uint8_t>> PNGCodec::EncodeBGRASkBitmap(
     const SkBitmap& input,
     bool discard_transparency) {
-  return EncodeSkBitmap(input, discard_transparency,
-                        SkPngRustEncoder::CompressionLevel::kMedium);
+  return EncodeSkBitmap(input, discard_transparency, 6,
+                        /*disable_filters=*/false);
 }
 
 std::optional<std::vector<uint8_t>> PNGCodec::FastEncodeBGRASkBitmap(
     const SkBitmap& input,
     bool discard_transparency) {
-  return EncodeSkBitmap(input, discard_transparency,
-                        SkPngRustEncoder::CompressionLevel::kLow);
+  return EncodeSkBitmap(input, discard_transparency, 1,
+                        /*disable_filters=*/true);
 }
 
 PNGCodec::Comment::Comment(const std::string& k, const std::string& t)
